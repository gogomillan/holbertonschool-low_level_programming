
PRINTF(3)                                           Linux Programmer's Manual                                           PRINTF(3)



NAME
       printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - formatted output conversion

SYNOPSIS
       #include <stdio.h>

       int printf(const char *format, ...);
       int fprintf(FILE *stream, const char *format, ...);
       int sprintf(char *str, const char *format, ...);
       int snprintf(char *str, size_t size, const char *format, ...);

       #include <stdarg.h>

       int vprintf(const char *format, va_list ap);
       int vfprintf(FILE *stream, const char *format, va_list ap);
       int vsprintf(char *str, const char *format, va_list ap);
       int vsnprintf(char *str, size_t size, const char *format, va_list ap);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       snprintf(), vsnprintf():
           _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L;
           or cc -std=c99

DESCRIPTION
       The  functions in the printf() family produce output according to a format as described below.  The functions printf() and
       vprintf() write output to stdout, the standard output stream; fprintf() and vfprintf() write output to  the  given  output
       stream; sprintf(), snprintf(), vsprintf() and vsnprintf() write to the character string str.

       The functions snprintf() and vsnprintf() write at most size bytes (including the terminating null byte ('\0')) to str.

       The  functions  vprintf(),  vfprintf(),  vsprintf(),  vsnprintf()  are  equivalent  to  the functions printf(), fprintf(),
       sprintf(), snprintf(), respectively, except that they are called with a va_list instead of a variable number of arguments.
       These  functions  do  not call the va_end macro.  Because they invoke the va_arg macro, the value of ap is undefined after
       the call.  See stdarg(3).

       These eight functions write the output under the control of a format string that specifies how  subsequent  arguments  (or
       arguments accessed via the variable-length argument facilities of stdarg(3)) are converted for output.

       C99 and POSIX.1-2001 specify that the results are undefined if a call to sprintf(), snprintf(), vsprintf(), or vsnprintf()
       would cause copying to take place between objects that overlap (e.g., if the target string array and one of  the  supplied
       input arguments refer to the same buffer).  See NOTES.

   Return value
       Upon  successful return, these functions return the number of characters printed (excluding the null byte used to end out‐
       put to strings).

       The functions snprintf() and vsnprintf() do not write more than size bytes (including the terminating null  byte  ('\0')).
       If the output was truncated due to this limit then the return value is the number of characters (excluding the terminating
       null byte) which would have been written to the final string if enough space had been available.  Thus, a return value  of
       size or more means that the output was truncated.  (See also below under NOTES.)

       If an output error is encountered, a negative value is returned.

   Format of the format string
       The  format  string  is a character string, beginning and ending in its initial shift state, if any.  The format string is
       composed of zero or more directives: ordinary characters (not %), which are copied unchanged to  the  output  stream;  and
       conversion  specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specifi‐
       cation is introduced by the character %, and ends with a conversion specifier.  In between there may be  (in  this  order)
       zero or more flags, an optional minimum field width, an optional precision and an optional length modifier.

       The  arguments  must  correspond properly (after type promotion) with the conversion specifier.  By default, the arguments
       are used in the order given, where each '*' and each conversion specifier asks for the next argument (and it is  an  error
       if insufficiently many arguments are given).  One can also specify explicitly which argument is taken, at each place where
       an argument is required, by writing "%m$" instead of '%' and "*m$" instead of '*', where the decimal integer m denotes the
       position in the argument list of the desired argument, indexed starting from 1.  Thus,

           printf("%*d", width, num);

       and

           printf("%2$*1$d", width, num);

       are  equivalent.  The second style allows repeated references to the same argument.  The C99 standard does not include the
       style using '$', which comes from the Single UNIX Specification.  If the style using '$' is used, it must be used through‐
       out  for  all  conversions taking an argument and all width and precision arguments, but it may be mixed with "%%" formats
       which do not consume an argument.  There may be no gaps in the numbers of arguments specified using '$'; for  example,  if
       arguments 1 and 3 are specified, argument 2 must also be specified somewhere in the format string.

       For  some  numeric  conversions  a radix character ("decimal point") or thousands' grouping character is used.  The actual
       character used depends on the LC_NUMERIC part of the locale.  The POSIX locale uses '.' as radix character, and  does  not
       have a grouping character.  Thus,

               printf("%'.2f", 1234567.89);

       results  in  "1234567.89"  in  the  POSIX  locale, in "1234567,89" in the nl_NL locale, and in "1.234.567,89" in the da_DK
       locale.

   The flag characters
       The character % is followed by zero or more of the following flags:

       #      The value should be converted to an "alternate form".  For o conversions, the first character of the output  string
              is  made  zero  (by  prefixing  a 0 if it was not zero already).  For x and X conversions, a nonzero result has the
              string "0x" (or "0X" for X conversions) prepended to it.  For a, A, e, E, f, F, g, and G  conversions,  the  result
              will  always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results
              of those conversions only if a digit follows).  For g and G conversions, trailing zeros are not  removed  from  the
              result as they would otherwise be.  For other conversions, the result is undefined.

       0      The value should be zero padded.  For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversions, the converted value
              is padded on the left with zeros rather than blanks.  If the 0 and - flags both appear, the 0 flag is ignored.   If
              a  precision  is  given with a numeric conversion (d, i, o, u, x, and X), the 0 flag is ignored.  For other conver‐
              sions, the behavior is undefined.

       -      The converted value is to be left adjusted on the field boundary.  (The default is  right  justification.)   Except
              for  n  conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or
              zeros.  A - overrides a 0 if both are given.

       ' '    (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion.

       +      A sign (+ or -) should always be placed before a number produced by a signed conversion.  By default a sign is used
              only for negative numbers.  A + overrides a space if both are used.

       The five flag characters above are defined in the C standard.  The SUSv2 specifies one further flag character.

       '      For decimal conversion (i, d, u, f, F, g, G) the output is to be grouped with thousands' grouping characters if the
              locale information indicates any.  Note that many versions of gcc(1) cannot parse this  option  and  will  issue  a
              warning.  SUSv2 does not include %'F.

       glibc 2.2 adds one further flag character.

       I      For decimal integer conversion (i, d, u) the output uses the locale's alternative output digits, if any.  For exam‐
              ple, since glibc 2.2.3 this will give Arabic-Indic digits in the Persian ("fa_IR") locale.

   The field width
       An optional decimal digit string (with nonzero first digit) specifying a minimum field width.  If the converted value  has
       fewer  characters  than  the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag
       has been given).  Instead of a decimal digit string one may write "*" or "*m$" (for some decimal  integer  m)  to  specify
       that  the  field width is given in the next argument, or in the m-th argument, respectively, which must be of type int.  A
       negative field width is taken as a '-' flag followed by a positive field width.  In no case does a  nonexistent  or  small
       field  width  cause  truncation  of  a  field;  if  the result of a conversion is wider than the field width, the field is
       expanded to contain the conversion result.

   The precision
       An optional precision, in the form of a period ('.')  followed by an optional decimal digit string.  Instead of a  decimal
       digit  string  one  may write "*" or "*m$" (for some decimal integer m) to specify that the precision is given in the next
       argument, or in the m-th argument, respectively, which must be of type int.  If the precision is given as  just  '.',  the
       precision  is  taken  to be zero.  A negative precision is taken as if the precision were omitted.  This gives the minimum
       number of digits to appear for d, i, o, u, x, and X conversions, the number of digits to appear after the radix  character
       for  a,  A,  e,  E, f, and F conversions, the maximum number of significant digits for g and G conversions, or the maximum
       number of characters to be printed from a string for s and S conversions.

   The length modifier
       Here, "integer conversion" stands for d, i, o, u, x, or X conversion.

       hh     A following integer conversion corresponds to a signed char or unsigned char argument, or a following n  conversion
              corresponds to a pointer to a signed char argument.

       h      A  following integer conversion corresponds to a short int or unsigned short int argument, or a following n conver‐
              sion corresponds to a pointer to a short int argument.

       l      (ell) A following integer conversion corresponds to a long int or unsigned long int argument, or a following n con‐
              version  corresponds to a pointer to a long int argument, or a following c conversion corresponds to a wint_t argu‐
              ment, or a following s conversion corresponds to a pointer to wchar_t argument.

       ll     (ell-ell).  A following integer conversion corresponds to a long long int or unsigned long long int argument, or  a
              following n conversion corresponds to a pointer to a long long int argument.

       L      A following a, A, e, E, f, F, g, or G conversion corresponds to a long double argument.  (C99 allows %LF, but SUSv2
              does not.)

       q      ("quad". 4.4BSD and Linux libc5 only.  Don't use.)  This is a synonym for ll.

       j      A following integer conversion corresponds to an intmax_t or uintmax_t argument.

       z      A following integer conversion corresponds to a size_t or ssize_t argument.  (Linux libc5 has Z with this  meaning.
              Don't use it.)

       t      A following integer conversion corresponds to a ptrdiff_t argument.

       The  SUSv2  knows  about only the length modifiers h (in hd, hi, ho, hx, hX, hn) and l (in ld, li, lo, lx, lX, ln, lc, ls)
       and L (in Le, LE, Lf, Lg, LG).

   The conversion specifier
       A character that specifies the type of conversion to be applied.  The conversion specifiers and their meanings are:

       d, i   The int argument is converted to signed decimal notation.  The precision, if any, gives the minimum number of  dig‐
              its  that  must  appear;  if  the  converted value requires fewer digits, it is padded on the left with zeros.  The
              default precision is 1.  When 0 is printed with an explicit precision 0, the output is empty.

       o, u, x, X
              The unsigned int argument is converted to unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x  and
              X)  notation.   The  letters abcdef are used for x conversions; the letters ABCDEF are used for X conversions.  The
              precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer  dig‐
              its,  it  is padded on the left with zeros.  The default precision is 1.  When 0 is printed with an explicit preci‐
              sion 0, the output is empty.

       e, E   The double argument is rounded and converted in the style [-]d.ddde±dd where there is one digit before the decimal-
              point  character  and  the  number of digits after it is equal to the precision; if the precision is missing, it is
              taken as 6; if the precision is zero, no decimal-point character appears.   An  E  conversion  uses  the  letter  E
              (rather than e) to introduce the exponent.  The exponent always contains at least two digits; if the value is zero,
              the exponent is 00.

       f, F   The double argument is rounded and converted to decimal notation in the style [-]ddd.ddd, where the number of  dig‐
              its  after the decimal-point character is equal to the precision specification.  If the precision is missing, it is
              taken as 6; if the precision is explicitly zero, no decimal-point character appears.  If a decimal  point  appears,
              at least one digit appears before it.

              (The  SUSv2  does  not know about F and says that character string representations for infinity and NaN may be made
              available.  The C99 standard specifies "[-]inf" or "[-]infinity" for infinity, and a string starting with "nan" for
              NaN, in the case of f conversion, and "[-]INF" or "[-]INFINITY" or "NAN*" in the case of F conversion.)

       g, G   The double argument is converted in style f or e (or F or E for G conversions).  The precision specifies the number
              of significant digits.  If the precision is missing, 6 digits are given; if the precision is zero, it is treated as
              1.   Style e is used if the exponent from its conversion is less than -4 or greater than or equal to the precision.
              Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it  is  followed
              by at least one digit.

       a, A   (C99;  not  in SUSv2) For a conversion, the double argument is converted to hexadecimal notation (using the letters
              abcdef) in the style [-]0xh.hhhhp±; for A conversion the prefix 0X, the letters ABCDEF, and the exponent  separator
              P  is used.  There is one hexadecimal digit before the decimal point, and the number of digits after it is equal to
              the precision.  The default precision suffices for an exact representation of the value if an exact  representation
              in  base  2  exists and otherwise is sufficiently large to distinguish values of type double.  The digit before the
              decimal point is unspecified for nonnormalized numbers, and nonzero but otherwise unspecified for  normalized  num‐
              bers.

       c      If  no  l  modifier  is  present, the int argument is converted to an unsigned char, and the resulting character is
              written.  If an l modifier is present, the wint_t (wide character) argument is converted to a multibyte sequence by
              a  call to the wcrtomb(3) function, with a conversion state starting in the initial state, and the resulting multi‐
              byte string is written.

       s      If no l modifier is present: The const char * argument is expected to be a pointer to an array  of  character  type
              (pointer  to  a  string).   Characters from the array are written up to (but not including) a terminating null byte
              ('\0'); if a precision is specified, no more than the number specified are written.  If a precision  is  given,  no
              null  byte  need be present; if the precision is not specified, or is greater than the size of the array, the array
              must contain a terminating null byte.

              If an l modifier is present: The const wchar_t * argument is expected to be a pointer to an array of  wide  charac‐
              ters.  Wide characters from the array are converted to multibyte characters (each by a call to the wcrtomb(3) func‐
              tion, with a conversion state starting in the initial state before the first wide character), up to and including a
              terminating null wide character.  The resulting multibyte characters are written up to (but not including) the ter‐
              minating null byte.  If a precision is specified, no more bytes than the number specified are written, but no  par‐
              tial  multibyte  characters  are  written.  Note that the precision determines the number of bytes written, not the
              number of wide characters or screen positions.  The array must contain a terminating null wide character, unless  a
              precision  is  given  and it is so small that the number of bytes written exceeds it before the end of the array is
              reached.

       C      (Not in C99, but in SUSv2.)  Synonym for lc.  Don't use.

       S      (Not in C99, but in SUSv2.)  Synonym for ls.  Don't use.

       p      The void * pointer argument is printed in hexadecimal (as if by %#x or %#lx).

       n      The number of characters written so far is stored into the integer indicated by  the  int *  (or  variant)  pointer
              argument.  No argument is converted.

       m      (Glibc extension.)  Print output of strerror(errno).  No argument is required.

       %      A '%' is written.  No argument is converted.  The complete conversion specification is '%%'.

CONFORMING TO
       The  fprintf(),  printf(),  sprintf(),  vprintf(),  vfprintf(),  and  vsprintf()  functions  conform  to C89 and C99.  The
       snprintf() and vsnprintf() functions conform to C99.

       Concerning the return value of snprintf(), SUSv2 and C99 contradict each other: when snprintf() is called with size=0 then
       SUSv2  stipulates  an  unspecified  return  value less than 1, while C99 allows str to be NULL in this case, and gives the
       return value (as always) as the number of characters that would have been written in case the output string has been large
       enough.

       Linux libc4 knows about the five C standard flags.  It knows about the length modifiers h, l, L, and the conversions c, d,
       e, E, f, F, g, G, i, n, o, p, s, u, x, and X, where F is a synonym for f.  Additionally, it accepts D, O, and  U  as  syn‐
       onyms  for  ld,  lo,  and  lu.  (This is bad, and caused serious bugs later, when support for %D disappeared.)  No locale-
       dependent radix character, no thousands' separator, no NaN or infinity, no "%m$" and "*m$".

       Linux libc5 knows about the five C standard flags and the ' flag, locale, "%m$" and "*m$".  It knows about the length mod‐
       ifiers  h,  l,  L, Z, and q, but accepts L and q both for long double and for long long int (this is a bug).  It no longer
       recognizes F, D, O, and U, but adds the conversion character m, which outputs strerror(errno).

       glibc 2.0 adds conversion characters C and S.

       glibc 2.1 adds length modifiers hh, j, t, and z and conversion characters a and A.

       glibc 2.2 adds the conversion character F with C99 semantics, and the flag character I.

NOTES
       Some programs imprudently rely on code such as the following

           sprintf(buf, "%s some further text", buf);

       to append text to buf.  However, the standards explicitly note that the results are undefined if  source  and  destination
       buffers overlap when calling sprintf(), snprintf(), vsprintf(), and vsnprintf().  Depending on the version of gcc(1) used,
       and the compiler options employed, calls such as the above will not produce the expected results.

       The glibc implementation of the functions snprintf() and vsnprintf() conforms to the C99 standard,  that  is,  behaves  as
       described above, since glibc version 2.1.  Until glibc 2.0.6 they would return -1 when the output was truncated.

BUGS
       Because  sprintf()  and  vsprintf()  assume an arbitrarily long string, callers must be careful not to overflow the actual
       space; this is often impossible to assure.  Note that the length of the strings produced is locale-dependent and difficult
       to predict.  Use snprintf() and vsnprintf() instead (or asprintf(3) and vasprintf(3)).

       Linux  libc4.[45]  does  not have a snprintf(), but provides a libbsd that contains an snprintf() equivalent to sprintf(),
       that is, one that ignores the size argument.  Thus, the use of snprintf() with early libc4 leads to serious security prob‐
       lems.

       Code  such  as  printf(foo); often indicates a bug, since foo may contain a % character.  If foo comes from untrusted user
       input, it may contain %n, causing the printf() call to write to memory and creating a security hole.

EXAMPLE
       To print Pi to five decimal places:

           #include <math.h>
           #include <stdio.h>
           fprintf(stdout, "pi = %.5f\n", 4 * atan(1.0));

       To print a date and time in the form "Sunday, July 3, 10:02", where weekday and month are pointers to strings:

           #include <stdio.h>
           fprintf(stdout, "%s, %s %d, %.2d:%.2d\n",
                   weekday, month, day, hour, min);

       Many countries use the day-month-year order.  Hence, an internationalized version must be able to print the  arguments  in
       an order specified by the format:

           #include <stdio.h>
           fprintf(stdout, format,
                   weekday, month, day, hour, min);

       where format depends on locale, and may permute the arguments.  With the value:

           "%1$s, %3$d. %2$s, %4$d:%5$.2d\n"

       one might obtain "Sonntag, 3. Juli, 10:02".

       To allocate a sufficiently large string and print into it (code correct for both glibc 2.0 and glibc 2.1):

       If truncation occurs in glibc versions prior to 2.0.6, this is treated as an error instead of being handled gracefully.

       #include <stdio.h>
       #include <stdlib.h>
       #include <stdarg.h>

       char *
       make_message(const char *fmt, ...)
       {
           int n;
           int size = 100;     /* Guess we need no more than 100 bytes */
           char *p, *np;
           va_list ap;

           if ((p = malloc(size)) == NULL)
               return NULL;

           while (1) {

               /* Try to print in the allocated space */

               va_start(ap, fmt);
               n = vsnprintf(p, size, fmt, ap);
               va_end(ap);

               /* Check error code */

               if (n < 0)
                   return NULL;

               /* If that worked, return the string */

               if (n < size)
                   return p;

               /* Else try again with more space */

               size = n + 1;       /* Precisely what is needed */


               if ((np = realloc (p, size)) == NULL) {
                   free(p);
                   return NULL;
               } else {
                   p = np;
               }
           }
       }

SEE ALSO
       printf(1), asprintf(3), dprintf(3), scanf(3), setlocale(3), wcrtomb(3), wprintf(3), locale(5)

COLOPHON
       This  page  is  part  of release 3.54 of the Linux man-pages project.  A description of the project, and information about
       reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



GNU                                                         2013-09-04                                                  PRINTF(3)


OPEN(2)                                             Linux Programmer's Manual                                             OPEN(2)



NAME
       open, creat - open and possibly create a file or device

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

DESCRIPTION
       Given  a  pathname for a file, open() returns a file descriptor, a small, nonnegative integer for use in subsequent system
       calls (read(2), write(2), lseek(2), fcntl(2), etc.).  The file descriptor returned by a successful call will be  the  low‐
       est-numbered file descriptor not currently open for the process.

       By  default,  the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor flag
       described in fcntl(2) is initially disabled; the O_CLOEXEC flag, described below, can be used  to  change  this  default).
       The file offset is set to the beginning of the file (see lseek(2)).

       A call to open() creates a new open file description, an entry in the system-wide table of open files.  This entry records
       the file offset and the file status flags (modifiable via the fcntl(2) F_SETFL operation).  A file descriptor is a  refer‐
       ence  to  one of these entries; this reference is unaffected if pathname is subsequently removed or modified to refer to a
       different file.  The new open file description is initially not shared with any other process, but sharing may  arise  via
       fork(2).

       The  argument  flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request opening
       the file read-only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags.  The file creation flags
       are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TRUNC, and O_TTY_INIT.  The file status flags are all
       of the remaining flags listed below.  The distinction between these two groups of flags is that the file status flags  can
       be  retrieved  and (in some cases) modified using fcntl(2).  The full list of file creation flags and file status flags is
       as follows:

       O_APPEND
              The file is opened in append mode.  Before each write(2), the file offset is positioned at the end of the file,  as
              if with lseek(2).  O_APPEND may lead to corrupted files on NFS filesystems if more than one process appends data to
              a file at once.  This is because NFS does not support appending to a file, so the client kernel has to simulate it,
              which can't be done without a race condition.

       O_ASYNC
              Enable  signal-driven I/O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or
              output becomes possible on this file descriptor.  This feature is available only  for  terminals,  pseudoterminals,
              sockets, and (since Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.

       O_CLOEXEC (Since Linux 2.6.23)
              Enable  the  close-on-exec flag for the new file descriptor.  Specifying this flag permits a program to avoid addi‐
              tional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.  Additionally, use of this flag is essential in some
              multithreaded  programs  since using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suf‐
              fice to avoid race conditions where one thread opens a file descriptor at the same time as another  thread  does  a
              fork(2) plus execve(2).

       O_CREAT
              If  the file does not exist it will be created.  The owner (user ID) of the file is set to the effective user ID of
              the process.  The group ownership (group ID) is set either to the effective group ID of the process or to the group
              ID  of  the parent directory (depending on filesystem type and mount options, and the mode of the parent directory,
              see the mount options bsdgroups and sysvgroups described in mount(8)).

              mode specifies the permissions to use in case a new file is created.  This argument must be supplied  when  O_CREAT
              is  specified  in flags; if O_CREAT is not specified, then mode is ignored.  The effective permissions are modified
              by the process's umask in the usual way: The permissions of the created file are (mode & ~umask).  Note  that  this
              mode  applies  only to future accesses of the newly created file; the open() call that creates a read-only file may
              well return a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700 user (file owner) has read, write and execute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write and execute permission

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

       O_DIRECT (Since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance,  but  it
              is useful in special situations, such as when applications do their own caching.  File I/O is done directly to/from
              user-space buffers.  The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does not give
              the  guarantees of the O_SYNC flag that data and necessary metadata are transferred.  To guarantee synchronous I/O,
              O_SYNC must be used in addition to O_DIRECT.  See NOTES below for further discussion.

              A semantically similar (but deprecated) interface for block devices is described in raw(8).

       O_DIRECTORY
              If pathname is not a directory, cause the open to fail.  This flag is Linux-specific, and was added in kernel  ver‐
              sion 2.1.126, to avoid denial-of-service problems if opendir(3) is called on a FIFO or tape device.

       O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already
              exists, then open() will fail.

              When these two flags are specified, symbolic links are not followed: if pathname is a symbolic  link,  then  open()
              fails regardless of where the symbolic link points to.

              In  general,  the  behavior of O_EXCL is undefined if it is used without O_CREAT.  There is one exception: on Linux
              2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a block device.  If the block device is  in
              use by the system (e.g., mounted), open() fails with the error EBUSY.

              On  NFS,  O_EXCL  is  supported  only  when using NFSv3 or later on kernel 2.6 or later.  In NFS environments where
              O_EXCL support is not provided, programs that rely on it for performing locking tasks will contain  a  race  condi‐
              tion.   Portable  programs that want to perform atomic file locking using a lockfile, and need to avoid reliance on
              NFS support for O_EXCL, can create a unique file on the same filesystem (e.g., incorporating hostname and PID), and
              use  link(2) to make a link to the lockfile.  If link(2) returns 0, the lock is successful.  Otherwise, use stat(2)
              on the unique file to check if its link count has increased to 2, in which case the lock is also successful.

       O_LARGEFILE
              (LFS) Allow files whose sizes cannot be represented in an off_t (but can  be  represented  in  an  off64_t)  to  be
              opened.   The _LARGEFILE64_SOURCE macro must be defined (before including any header files) in order to obtain this
              definition.  Setting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using  O_LARGEFILE)  is  the  pre‐
              ferred method of accessing large files on 32-bit systems (see feature_test_macros(7)).

       O_NOATIME (Since Linux 2.6.8)
              Do  not  update  the file last access time (st_atime in the inode) when the file is read(2).  This flag is intended
              for use by indexing or backup programs, where its use can significantly reduce the amount of disk  activity.   This
              flag may not be effective on all filesystems.  One example is NFS, where the server maintains the access time.

       O_NOCTTY
              If  pathname  refers  to a terminal device—see tty(4)—it will not become the process's controlling terminal even if
              the process does not have one.

       O_NOFOLLOW
              If pathname is a symbolic link, then the open fails.  This is a FreeBSD extension, which was added to Linux in ver‐
              sion  2.1.126.   Symbolic  links  in  earlier components of the pathname will still be followed.  See also O_NOPATH
              below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Neither the open() nor any  subsequent  operations  on  the
              file descriptor which is returned will cause the calling process to wait.  For the handling of FIFOs (named pipes),
              see also fifo(7).  For a discussion of the effect of O_NONBLOCK in conjunction with mandatory file locks  and  with
              file leases, see fcntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain  a  file  descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to
              perform operations that act purely at the file descriptor level.  The file itself is not  opened,  and  other  file
              operations (e.g., read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), mmap(2)) fail with the error EBADF.

              The following operations can be performed on the resulting file descriptor:

              *  close(2); fchdir(2) (since Linux 3.5); fstat(2) (since Linux 3.6).

              *  Duplicating the file descriptor (dup(2), fcntl(2) F_DUPFD, etc.).

              *  Getting and setting file descriptor flags (fcntl(2) F_GETFD and F_SETFD).

              *  Retrieving  open file status flags using the fcntl(2) F_GETFL operation: the returned flags will include the bit
                 O_PATH.


              *  Passing the file descriptor as the dirfd argument of openat(2) and the other "*at()" system calls.

              *  Passing the file descriptor to another process via a UNIX domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in flags, flag bits other than O_DIRECTORY and O_NOFOLLOW are ignored.

              If the O_NOFOLLOW flag is also specified, then the call returns a file descriptor referring to the  symbolic  link.
              This  file  descriptor  can be used as the dirfd argument in calls to fchownat(2), fstatat(2), linkat(2), and read‐
              linkat(2) with an empty pathname to have the calls operate on the symbolic link.

       O_SYNC The file is opened for synchronous I/O.  Any write(2)s on the resulting file  descriptor  will  block  the  calling
              process until the data has been physically written to the underlying hardware.  But see NOTES below.

       O_TRUNC
              If  the file already exists and is a regular file and the open mode allows writing (i.e., is O_RDWR or O_WRONLY) it
              will be truncated to length 0.  If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored.  Other‐
              wise the effect of O_TRUNC is unspecified.

       Some of these optional flags can be altered using fcntl(2) after the file has been opened.

       creat() is equivalent to open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

RETURN VALUE
       open() and creat() return the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately).

ERRORS
       EACCES The  requested  access to the file is not allowed, or search permission is denied for one of the directories in the
              path prefix of pathname, or the file did not exist yet and write access to the parent  directory  is  not  allowed.
              (See also path_resolution(7).)

       EDQUOT Where  O_CREAT is specified, the file does not exist, and the user's quota of disk blocks or inodes on the filesys‐
              tem has been exhausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While blocked waiting to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was interrupted by
              a signal handler; see signal(7).

       EINVAL The filesystem does not support the O_DIRECT flag. See NOTES for more information.

       EISDIR pathname refers to a directory and the access requested involved writing (that is, O_WRONLY or O_RDWR is set).

       ELOOP  Too many symbolic links were encountered in resolving pathname, or O_NOFOLLOW was specified but pathname was a sym‐
              bolic link.

       EMFILE The process already has the maximum number of files open.

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system limit on the total number of open files has been reached.

       ENODEV pathname refers to a device special file and no corresponding device exists.  (This is a Linux kernel bug; in  this
              situation ENXIO must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.  Or, a directory component in pathname does not exist or is a
              dangling symbolic link.

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname was to be created but the device containing pathname has no room for the new file.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory, or O_DIRECTORY was specified and pathname
              was not a directory.

       ENXIO  O_NONBLOCK  | O_WRONLY is set, the named file is a FIFO and no process has the file open for reading.  Or, the file
              is a device special file and no corresponding device exists.

       EOVERFLOW
              pathname refers to a regular file that is too large to be opened.  The usual scenario here is that  an  application
              compiled  on  a  32-bit  platform  without -D_FILE_OFFSET_BITS=64 tried to open a file whose size exceeds (2<<31)-1
              bits; see also O_LARGEFILE above.  This is the error specified by POSIX.1-2001; in  kernels  before  2.6.24,  Linux
              gave the error EFBIG for this case.

       EPERM  The  O_NOATIME  flag was specified, but the effective user ID of the caller did not match the owner of the file and
              the caller was not privileged (CAP_FOWNER).

       EROFS  pathname refers to a file on a read-only filesystem and write access was requested.

       ETXTBSY
              pathname refers to an executable image which is currently being executed and write access was requested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease was held on the file (see fcntl(2)).

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.  The O_DIRECTORY, O_NOATIME, O_NOFOLLOW, and O_PATH flags are Linux-specific, and one may need
       to define _GNU_SOURCE (before including any header files) to obtain their definitions.

       The O_CLOEXEC flag is not specified in POSIX.1-2001, but is specified in POSIX.1-2008.

       O_DIRECT  is  not specified in POSIX; one has to define _GNU_SOURCE (before including any header files) to get its defini‐
       tion.

NOTES
       Under Linux, the O_NONBLOCK flag indicates that one wants to open but does not necessarily have the intention to  read  or
       write.  This is typically used to open devices in order to get a file descriptor for use with ioctl(2).

       Unlike  the  other  values  that  can be specified in flags, the access mode values O_RDONLY, O_WRONLY, and O_RDWR, do not
       specify individual bits.  Rather, they define the low order two bits of flags, and are defined respectively as 0,  1,  and
       2.   In  other words, the combination O_RDONLY | O_WRONLY is a logical error, and certainly does not have the same meaning
       as O_RDWR.  Linux reserves the special, nonstandard access mode 3 (binary 11) in flags to mean: check for read  and  write
       permission on the file and return a descriptor that can't be used for reading or writing.  This nonstandard access mode is
       used by some Linux drivers to return a descriptor that is to be used only for device-specific ioctl(2) operations.

       The (undefined) effect of O_RDONLY | O_TRUNC varies among implementations.  On many systems the  file  is  actually  trun‐
       cated.

       There are many infelicities in the protocol underlying NFS, affecting amongst others O_SYNC and O_NDELAY.

       POSIX  provides for three different variants of synchronized I/O, corresponding to the flags O_SYNC, O_DSYNC, and O_RSYNC.
       Currently (2.6.31), Linux implements only O_SYNC, but glibc maps O_DSYNC and  O_RSYNC  to  the  same  numerical  value  as
       O_SYNC.  Most Linux filesystems don't actually implement the POSIX O_SYNC semantics, which require all metadata updates of
       a write to be on disk on returning to user space, but only the O_DSYNC semantics, which require only actual file data  and
       metadata necessary to retrieve it to be on disk by the time the system call returns.

       Note that open() can open device special files, but creat() cannot create them; use mknod(2) instead.

       On  NFS  filesystems  with UID mapping enabled, open() may return a file descriptor but, for example, read(2) requests are
       denied with EACCES.  This is because the client performs open() by checking the permissions, but UID mapping is  performed
       by the server upon read and write requests.

       If  the  file  is  newly created, its st_atime, st_ctime, st_mtime fields (respectively, time of last access, time of last
       status change, and time of last modification; see stat(2)) are set to the current  time,  and  so  are  the  st_ctime  and
       st_mtime fields of the parent directory.  Otherwise, if the file is modified because of the O_TRUNC flag, its st_ctime and
       st_mtime fields are set to the current time.

   O_DIRECT
       The O_DIRECT flag may impose alignment restrictions on the length and address of user-space buffers and the file offset of
       I/Os.   In Linux alignment restrictions vary by filesystem and kernel version and might be absent entirely.  However there
       is currently no filesystem-independent interface for an application to discover these restrictions for  a  given  file  or
       filesystem.   Some  filesystems  provide  their  own interfaces for doing so, for example the XFS_IOC_DIOINFO operation in
       xfsctl(3).

       Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all  be  multiples  of  the
       logical block size of the filesystem.  Under Linux 2.6, alignment to 512-byte boundaries suffices.

       O_DIRECT  I/Os  should  never  be run concurrently with the fork(2) system call, if the memory buffer is a private mapping
       (i.e., any mapping created with the mmap(2) MAP_PRIVATE flag; this includes memory allocated on the  heap  and  statically
       allocated  buffers).   Any  such  I/Os,  whether submitted via an asynchronous I/O interface or from another thread in the
       process, should be completed before fork(2) is called.  Failure to do so can  result  in  data  corruption  and  undefined
       behavior  in parent and child processes.  This restriction does not apply when the memory buffer for the O_DIRECT I/Os was
       created using shmat(2) or mmap(2) with the MAP_SHARED flag.  Nor does this restriction apply when the  memory  buffer  has
       been advised as MADV_DONTFORK with madvise(2), ensuring that it will not be available to the child after fork(2).

       The O_DIRECT flag was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4.  IRIX has
       also a fcntl(2) call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a flag  of  the  same  name,  but
       without alignment restrictions.

       O_DIRECT  support  was  added  under  Linux  in kernel version 2.4.10.  Older Linux kernels simply ignore this flag.  Some
       filesystems may not implement the flag and open() will fail with EINVAL if it is used.

       Applications should avoid mixing O_DIRECT and normal I/O to the same file, and especially to overlapping byte  regions  in
       the  same file.  Even when the filesystem correctly handles the coherency issues in this situation, overall I/O throughput
       is likely to be slower than using either mode alone.  Likewise, applications should avoid mixing  mmap(2)  of  files  with
       direct I/O to the same files.

       The  behaviour  of  O_DIRECT with NFS will differ from local filesystems.  Older kernels, or kernels configured in certain
       ways, may not support this combination.  The NFS protocol does not support passing the flag to the server, so O_DIRECT I/O
       will bypass the page cache only on the client; the server may still cache the I/O.  The client asks the server to make the
       I/O synchronous to preserve the synchronous semantics of O_DIRECT.  Some servers will perform poorly under  these  circum‐
       stances,  especially if the I/O size is small.  Some servers may also be configured to lie to clients about the I/O having
       reached stable storage; this will avoid the performance penalty at some risk to data integrity  in  the  event  of  server
       power failure.  The Linux NFS client places no alignment restrictions on O_DIRECT I/O.

       In summary, O_DIRECT is a potentially powerful tool that should be used with caution.  It is recommended that applications
       treat use of O_DIRECT as a performance option which is disabled by default.

              "The thing that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and was probably
              designed by a deranged monkey on some serious mind-controlling substances."—Linus

BUGS
       Currently,  it  is  not  possible  to  enable signal-driven I/O by specifying O_ASYNC when calling open(); use fcntl(2) to
       enable this flag.

SEE ALSO
       chmod(2), chown(2), close(2), dup(2), fcntl(2),  link(2),  lseek(2),  mknod(2),  mmap(2),  mount(2),  openat(2),  read(2),
       socket(2), stat(2), umask(2), unlink(2), write(2), fopen(3), fifo(7), path_resolution(7), symlink(7)

COLOPHON
       This  page  is  part  of release 3.54 of the Linux man-pages project.  A description of the project, and information about
       reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                       2013-08-09                                                    OPEN(2)
